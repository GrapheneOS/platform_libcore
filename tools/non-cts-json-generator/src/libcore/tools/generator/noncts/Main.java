/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package libcore.tools.generator.noncts;

import com.android.json.stream.JsonWriter;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import com.beust.jcommander.converters.FileConverter;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import vogar.expect.Expectation;
import vogar.expect.ExpectationStore;
import vogar.expect.ModeId;
import vogar.expect.util.Log;
import vogar.expect.util.LogOutput;

public class Main {


    private static class MainArgs {

        @Parameter(names = "-h", help = true, description = "Shows this help message")
        public boolean help = false;

        @Parameter(converter = FileConverter.class, description = "list of jar files")
        public List<File> inputFiles = new ArrayList<>();
    }

    public static void main(String[] argv) {
        MainArgs mainArgs = new MainArgs();

        JCommander jCommander = JCommander.newBuilder()
                .addObject(mainArgs)
                .build();
        jCommander.parse(argv);

        if (mainArgs.help) {
            jCommander.usage();
            return;
        }

        // See "libcore-non-cts-tests-txt" soong module where System.out is piped into
        // skippedCtsTest.txt
        PrintStream out = System.out;
        out.println("/* Do not modify directly.");
        out.println(" * Generated by tools/non-cts-json-generator/update_skippedCtsTest.sh");
        out.println(" * which dumps all @NonCts tests.");
        out.println(" */");


        NonCtsAnnotationReader reader = new NonCtsAnnotationReader(mainArgs.inputFiles).parse();
        ExpectationStore baseStore = readBaseExpectationStore();
        ExpectationWriter writer = ExpectationWriter.from(baseStore, reader);
        try {
            writer.write(out);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private static ExpectationStore readBaseExpectationStore() {
        Log.setOutput(new LogOutput() {
            @Override
            public void verbose(String s) {
                System.err.println(s);
            }

            @Override
            public void warn(String message) {
                System.err.println(message);
            }

            @Override
            public void warn(String message, List<String> list) {
                System.err.printf(message + '\n', list.toArray());
            }

            @Override
            public void nativeOutput(String outputLine) {
                System.err.println(outputLine);
            }

            @Override
            public void info(String s) {}

            @Override
            public void info(String message, Throwable throwable) {}
        });
        try {
            return ExpectationStore.parseResources(Main.class,
                    Set.of("/skippedCtsTest_manual_base.txt"), ModeId.HOST);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    /**
     * Read {@link libcore.test.annotation.NonCts} annotations from the .class files in the give
     * jar files.
     */
    private static class NonCtsAnnotationReader {
        private final List<NonCtsEntry> mEntries = new ArrayList<>();

        private final List<File> mJarFiles;
        public NonCtsAnnotationReader(List<File> jarFiles) {
            mJarFiles = jarFiles;
        }

        public List<NonCtsEntry> getEntries() {
            return mEntries;
        }

        public NonCtsAnnotationReader parse() {
            for (File jarFile : mJarFiles) {
                try (ZipFile zipFile = new ZipFile(jarFile)) {
                    var zipEntries = zipFile.entries();
                    while (zipEntries.hasMoreElements()) {
                        ZipEntry zipEntry = zipEntries.nextElement();
                        if (!zipEntry.getName().endsWith(".class")) {
                            continue;
                        }

                        ClassNode classNode = parseClass(zipFile, zipEntry);
                        storeIfNonCts(classNode);
                        String className = Type.getObjectType(classNode.name).getClassName();
                        for (MethodNode methodNode : classNode.methods) {
                            storeIfNonCts(className, methodNode);
                        }
                    }
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }

            return this;
        }
        private static ClassNode parseClass(ZipFile zipFile, ZipEntry zipEntry) throws IOException {
            try (InputStream in = zipFile.getInputStream(zipEntry)) {
                ClassReader classReader = new ClassReader(in);
                ClassNode node = new ClassNode();
                classReader.accept(node, 0);
                return node;
            }
        }

        private void storeIfNonCts(String className, MethodNode node) {
            if (node.visibleAnnotations == null) {
                return;
            }

            String methodName = className + "#" + node.name;
            storeIfNonCts(node.visibleAnnotations, methodName);
        }

        private void storeIfNonCts(ClassNode node) {
            if (node.visibleAnnotations == null) {
                return;
            }

            String className = Type.getObjectType(node.name).getClassName();
            storeIfNonCts(node.visibleAnnotations, className);
        }

        private void storeIfNonCts(List<AnnotationNode> visibleAnnotations, String name) {
            visibleAnnotations.stream()
                    .filter(a -> "Llibcore/test/annotation/NonCts;".equals(a.desc))
                    .map(a -> {
                        Long bug = -1L;
                        String desc = null;
                        for (int i = 0; i < a.values.size() - 1; i = i + 2) {
                            if (!(a.values.get(i) instanceof String key)) {
                                continue;
                            }
                            switch(key) {
                                case "bug" -> bug = (Long) a.values.get(i + 1);
                                case "reason" -> desc = (String) a.values.get(i + 1);
                            }
                        }
                        return new NonCtsEntry(name, bug, desc);
                    })
                    .findFirst()
                    .ifPresent(mEntries::add);
        }
    }


    /**
     * Write the expectation into the format read by {@link vogar.expect.ExpectationStore}.
     */
    public static class ExpectationWriter {
        private final TreeMap<NonCtsCluster.Key, NonCtsCluster> clusterMap;

        private ExpectationWriter(TreeMap<NonCtsCluster.Key, NonCtsCluster> clusterMap) {
            this.clusterMap = clusterMap;
        }

        public static ExpectationWriter from(ExpectationStore baseStore,
                NonCtsAnnotationReader annotationReader) {
            TreeMap<NonCtsCluster.Key, NonCtsCluster> clusterMap = new TreeMap<>();
            for (NonCtsEntry entry : annotationReader.getEntries()) {
                NonCtsCluster.Key key = new NonCtsCluster.Key(entry);
                clusterMap.compute(key, (k, cluster) -> {
                    if (cluster == null) {
                        cluster = new NonCtsCluster(k);
                    }
                    cluster.add(entry.name());
                    return cluster;
                });
            }
            for (var entry : baseStore.getAllOutComes().entrySet()) {
                NonCtsCluster.Key key = new NonCtsCluster.Key(entry.getValue());
                String testName = entry.getKey();
                clusterMap.compute(key, (k, cluster) -> {
                    if (cluster == null) {
                        cluster = new NonCtsCluster(k);
                    }
                    cluster.add(testName);
                    return cluster;
                });
            }

            return new ExpectationWriter(clusterMap);
        }

        public void write(OutputStream out) throws IOException {
            Writer writer = new PrintWriter(out);
            JsonWriter jsonWriter = new JsonWriter(writer);
            jsonWriter.setIndent("  ");
            jsonWriter.beginArray();

            for (NonCtsCluster cluster : clusterMap.values()) {
                jsonWriter.beginObject();
                if (cluster.key.bug != -1) {
                    jsonWriter.name("bug");
                    jsonWriter.value(cluster.key.bug);
                }
                String description = cluster.key.description;
                if (description == null) {
                    description = "";
                }
                jsonWriter.name("description");
                jsonWriter.value(description);

                jsonWriter.name("names");
                jsonWriter.beginArray();
                for (String testName : cluster.testNames) {
                    jsonWriter.value(testName);
                }

                jsonWriter.endArray();
                jsonWriter.endObject();
            }

            jsonWriter.endArray();

            jsonWriter.flush();
        }
    }

    /**
     * This data class is very similar {@link vogar.expect.Expectation}, but contains only the name
     * and attributes supported by {@link libcore.test.annotation.NonCts}.
     */
    public record NonCtsEntry(String name, long bug, String description) {}

    public static final class NonCtsCluster {
        public final Key key;

        public final TreeSet<String> testNames = new TreeSet<>();

        public record Key(long bug, String description) implements Comparable<Key> {

            private static final Comparator<Key> COMPARATOR = Comparator.comparing(Key::bug)
                    .thenComparing(Key::description);
            public Key(NonCtsEntry entry) {
                this(entry.bug, entry.description);
            }
            public Key(Expectation e) {
                this(e.getBug(), e.getDescription());
            }

            @Override
            public int compareTo(Key key2) {
                return COMPARATOR.compare(this, key2);
            }
        }

        public NonCtsCluster(Key key) {
            this.key = key;
        }

        public NonCtsCluster add(String testName) {
            testNames.add(testName);
            return this;
        }
    }
}

